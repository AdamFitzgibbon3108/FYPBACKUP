package com.example.service;

import com.example.model.Question;
import com.example.model.QuestionType;
import com.example.repository.QuestionRepository;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.*;

@Service
public class QuestionService {   

    private static final String BASE_TRIVIA_API_URL = "https://opentdb.com/api.php?amount=%d&category=18&type=multiple";

    private final RestTemplate restTemplate;
    private final ObjectMapper objectMapper;

    @Autowired
    private QuestionRepository questionRepository;

    public QuestionService() {
        this.restTemplate = new RestTemplate();
        this.objectMapper = new ObjectMapper();
    }

    public List<Map<String, Object>> getQuestionsForRole(String role, String difficulty) {
        List<Map<String, Object>> questions = new ArrayList<>();

        // Fetch security-based questions from MySQL database
        List<Question> securityQuestions = questionRepository.findByRoleAndDifficulty(role, difficulty);
        for (Question sq : securityQuestions) {
            Map<String, Object> questionData = new HashMap<>();
            questionData.put("id", sq.getId());
            questionData.put("question", sq.getText());
            questionData.put("questionType", sq.getQuestionType().toString());

            // Add options for TRUE_FALSE or MULTIPLE_CHOICE questions
            if (sq.getQuestionType() == QuestionType.TRUE_FALSE) {
                questionData.put("options", List.of("True", "False"));
            } else if (sq.getQuestionType() == QuestionType.MULTIPLE_CHOICE && sq.getOptions() != null && !((JsonNode) sq.getOptions()).isEmpty()) {
                questionData.put("options", sq.getOptions()); // Use actual options from the database
            } else {
                continue; // Skip questions without answer options
            }

            questions.add(questionData);
        }

        // Fetch computing questions from API if not enough questions exist
        int apiQuestionsNeeded = 15 - questions.size();
        if (apiQuestionsNeeded > 0) {
            String apiUrl = String.format(BASE_TRIVIA_API_URL, apiQuestionsNeeded) + "&difficulty=" + mapRoleToDifficulty(role, difficulty);
            try {
                String response = restTemplate.getForObject(apiUrl, String.class);
                JsonNode jsonNode = objectMapper.readTree(response);
                JsonNode results = jsonNode.get("results");

                for (JsonNode result : results) {
                    Map<String, Object> questionData = new HashMap<>();
                    questionData.put("question", result.get("question").asText());

                    List<String> options = new ArrayList<>();
                    result.get("incorrect_answers").forEach(answer -> options.add(answer.asText()));
                    options.add(result.get("correct_answer").asText());

                    Collections.shuffle(options);

                    if (!options.isEmpty()) {
                        questionData.put("options", options);
                        questionData.put("correctAnswer", result.get("correct_answer").asText());
                        questionData.put("questionType", "MULTIPLE_CHOICE");
                        questions.add(questionData);
                    }
                }
            } catch (Exception e) {
                System.out.println("Trivia API fetch error: " + e.getMessage());
            }
        }

        Collections.shuffle(questions);
        return questions;
    }

    // Map the role to difficulty level
    private String mapRoleToDifficulty(String role, String difficulty) {
        if (difficulty != null && !difficulty.isEmpty()) {
            return difficulty.toLowerCase(); // Convert user selection to API format
        }

        switch (role.toLowerCase()) {
            case "developer":
                return "medium";
            case "analyst":
                return "hard";
            case "manager":
                return "easy";
            default:
                return "medium"; // Default difficulty if not provided
        }
    }
}




