package com.example.controller;

import com.example.model.Question;
import com.example.model.Response;
import com.example.model.User;
import com.example.service.QuestionService;
import com.example.repository.QuestionRepository;
import com.example.repository.ResponseRepository;
import com.example.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.Optional;

@Controller
@RequestMapping("/questionnaire")
public class QuestionController {

    @Autowired
    private QuestionRepository questionRepository;

    @Autowired
    private ResponseRepository responseRepository;

    @Autowired
    private UserRepository userRepository; // Inject user repository

    @Autowired
    private QuestionService questionService;

    @GetMapping("/parameter-selection")
    public String showParameterSelection() {
        return "parameterSelection";
    }

    @PostMapping("/start")
    public String startQuestionnaire(@RequestParam("selectedRole") String selectedRole,
                                     @RequestParam(value = "selectedDifficulty", required = false) String selectedDifficulty,
                                     Model model) {
        List<Map<String, Object>> questions = questionService.getQuestionsForRole(selectedRole, selectedDifficulty);
        model.addAttribute("selectedRole", selectedRole);
        model.addAttribute("selectedDifficulty", selectedDifficulty);
        model.addAttribute("questions", questions);

        return "questionnaire";
    }

    @PostMapping("/submit")
    public String submitQuestionnaire(@RequestParam Map<String, String> responses,
                                      @RequestParam("selectedRole") String selectedRole,
                                      @RequestParam("selectedDifficulty") String selectedDifficulty,
                                      Model model) {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        String username = authentication.getName();

        Optional<User> userOptional = Optional.ofNullable(userRepository.findByUsername(username));
        if (userOptional.isEmpty()) {
            return "error"; // Redirect to an error page if user is not found
        }

        User user = userOptional.get(); // Retrieve the logged-in user

        for (Map.Entry<String, String> entry : responses.entrySet()) {
            if (entry.getKey().startsWith("question_")) {
                try {
                    Long questionId = Long.parseLong(entry.getKey().replace("question_", ""));
                    String answer = entry.getValue();

                    Optional<Question> questionOptional = questionRepository.findById(questionId);
                    if (questionOptional.isPresent()) {
                        Response response = new Response();
                        response.setUser(user); // Set the user
                        response.setQuestion(questionOptional.get());
                        response.setAnswer(answer);
                        response.setTimestamp(LocalDateTime.now());
                        response.setRole(selectedRole);
                        response.setDifficulty(selectedDifficulty);

                        responseRepository.save(response);
                    }
                } catch (NumberFormatException e) {
                    System.out.println("Warning: Could not parse question ID: " + entry.getKey());
                }
            }
        }

        return "thankYou"; 
    }
}

